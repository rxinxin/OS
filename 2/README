This code contains implementations of memory management software to initialize a two-layer virtual memory system as well as implement paging. The code, to our knowledge, works in every respect. We are able to run with the given value of 32 PAGEABLE_PAGES, albeit very slow. When we increase N_PROCESS_STACK_PAGES, our page_replacement_policy returns -1 since it has no more pages to give. We currently have an assertion that will catch this in page_swap_out. We decided that an assertion was appropriate here as any code using this funcitonality should be forced to not use page_swap_out with negative values. It would make more sense to pass an error up to the kernel and let the kernel decide how to deal with it, but we decided not to do this since we aren't developing the kernel.

One thing to note about or design is that we do not load all pages associated with a process in batch. We wait for a page to be requested due to a page fault before loading any of them in.

We have implemented the extra credit, FIFO with second chance. It is currently turned off, but can be turned on by changing the constant "EXTRA_CREDIT" to "TRUE" in memory.h. The implementation was fairly straightforward: we simply check for the PE_A flag in the page table entry. If it is set, we move the page_map_entry to the back of the queue and unset the flag. Otherwise, we evict that page.